[
    {
        "id": "1",
        "name": ".env",
        "path": ".env",
        "description": "environment configuration file.",
        "details": {
            "purpose": "Provides example environment variables for development.",
            "content": [
                "OPENAI_API_KEY=\"Enter Key Here\"",
                "SUPABASE_URL=\"Enter Key Here\"",
                "SUPABASE_ANON_KEY=\"Enter Key Here\"",
                "PORT=3001"
            ],
            "notes": [
                "Replace the placeholder values with actual keys and URLs for your development environment to ensure proper functionality. The OPENAI_API_KEY is required for accessing OpenAI's API, SUPABASE_URL and SUPABASE_ANON_KEY are needed for connecting to your Supabase database, and PORT specifies the port on which your application will run."
            ]
        }
    },
    {
        "id": "2",
        "name": ".gitignore",
        "path": ".gitignore",
        "description": "Specifies files and directories to be ignored by Git.",
        "details": {
            "purpose": "Defines untracked files that Git should ignore.",
            "content": [
                "node_modules/",
                ".env"
            ],
            "notes": [
                "This .gitignore file ensures that the 'node_modules' directory, which contains all your npm dependencies, and the '.env' file, which holds your environment variables, are not tracked by Git. This helps keep your repository clean and secure by excluding large dependency directories and sensitive information."
            ]
        }
    },
    {
        "id": "3",
        "name": "LICENSE.md",
        "path": "LICENSE.md",
        "description": "Contains the project's license information.",
        "details": {
            "purpose": "Provides the terms and conditions for using, copying, and distributing the software.",
            "content": [
                "MIT License",
                "",
                "Copyright (c) 2023 Mi'gmaq Foundation",
                "",
                "Permission is hereby granted, free of charge, to any person obtaining a copy",
                "of this software and associated documentation files (the \"Software\"), to deal",
                "in the Software without restriction, including without limitation the rights",
                "to use, copy, modify, merge, publish, distribute, sublicense, and/or sell",
                "copies of the Software, and to permit persons to whom the Software is",
                "furnished to do so, subject to the following conditions:",
                "",
                "The above copyright notice and this permission notice shall be included in all",
                "copies or substantial portions of the Software.",
                "",
                "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR",
                "IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,",
                "FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE",
                "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER",
                "LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,",
                "OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE",
                "SOFTWARE."
            ],
            "notes": [
                "This is a standard MIT License. Ensure you understand the implications of using this license in your project."
            ]
        }
    },
    {
        "id": "4",
        "name": "README.md",
        "path": "README.md",
        "description": "Contains the project's readme information.",
        "details": {
            "purpose": "Provides an overview of the project, setup instructions, and usage guidelines.",
            "content": [
                "# Mi'gmaq Foundation",
                "",
                "- Welcome to the Mi'gmaq Foundation repository. This project aims to provide educational resources and tools for learning and preserving the Mi'gmaq language.",
                "",
                "## Table of Contents",
                "",
                "- [Project Structure](#project-structure)",
                "- [API Endpoints](#api-endpoints)",
                "- [Client-side Code](#client-side-code)",
                "- [Server-side Code](#server-side-code)",
                "- [Contributing](#contributing)",
                "- [License](#license)",
                "",
                "## Project Structure",
                "",
                "Mi'gmaq Foundation",
                "\u251c\u2500\u2500 .env.sample",
                "\u251c\u2500\u2500 .gitignore",
                "\u251c\u2500\u2500 LICENSE.md",
                "\u251c\u2500\u2500 README.md",
                "\u251c\u2500\u2500 package-lock.json",
                "\u251c\u2500\u2500 package.json",
                "\u251c\u2500\u2500 tailwind.config.js",
                "\u251c\u2500\u2500 vercel.json",
                "\u251c\u2500\u2500 client",
                "\u2502   \u251c\u2500\u2500 css",
                "\u2502   \u2502   \u251c\u2500\u2500 input.css",
                "\u2502   \u2502   \u251c\u2500\u2500 output.css",
                "\u2502   \u251c\u2500\u2500 js",
                "\u2502   \u2502   \u251c\u2500\u2500 index.js",
                "\u2502   \u2502   \u251c\u2500\u2500 wordOfTheDay.js",
                "\u2502   \u2502   \u251c\u2500\u2500 dictionary.js",
                "\u2502   \u2502   \u251c\u2500\u2500 word-details.js",
                "\u2502   \u2502   \u251c\u2500\u2500 utils",
                "\u2502   \u2502   \u2502   \u251c\u2500\u2500 theme-toggle.js",
                "\u2502   \u2502   \u251c\u2500\u2500 games",
                "\u2502   \u2502   \u2502   \u251c\u2500\u2500 flashcard.js",
                "\u2502   \u2502   \u251c\u2500\u2500 lessons",
                "\u2502   \u2502   \u2502   \u251c\u2500\u2500 lesson1.js",
                "\u2502   \u2502   \u251c\u2500\u2500 resources",
                "\u2502   \u2502       \u251c\u2500\u2500 resource1.js",
                "\u2502   \u251c\u2500\u2500 pages",
                "\u2502   \u2502   \u251c\u2500\u2500 index.html",
                "\u2502   \u2502   \u251c\u2500\u2500 education.html",
                "\u2502   \u2502   \u251c\u2500\u2500 dictionary.html",
                "\u2502   \u2502   \u251c\u2500\u2500 word-details.html",
                "\u2502   \u2502   \u251c\u2500\u2500 games",
                "\u2502   \u2502   \u2502   \u251c\u2500\u2500 flashcard.html",
                "\u2502   \u2502   \u251c\u2500\u2500 lessons",
                "\u2502   \u2502   \u2502   \u251c\u2500\u2500 lesson1.html",
                "\u2502   \u2502   \u251c\u2500\u2500 resources",
                "\u2502   \u2502       \u251c\u2500\u2500 resource1.html",
                "\u2502   \u251c\u2500\u2500 assets",
                "\u2502   \u2502   \u251c\u2500\u2500 dictionary.json",
                "\u251c\u2500\u2500 server",
                "\u2502   \u251c\u2500\u2500 config",
                "\u2502   \u2502   \u251c\u2500\u2500 database.js",
                "\u2502   \u2502   \u251c\u2500\u2500 openai.js",
                "\u2502   \u251c\u2500\u2500 controllers",
                "\u2502   \u2502   \u251c\u2500\u2500 dictionaryController.js",
                "\u2502   \u2502   \u251c\u2500\u2500 wordOfTheDayController.js",
                "\u2502   \u2502   \u251c\u2500\u2500 aiController.js",
                "\u2502   \u2502   \u251c\u2500\u2500 commentsController.js",
                "\u2502   \u2502   \u251c\u2500\u2500 games",
                "\u2502   \u2502   \u2502   \u251c\u2500\u2500 gamesController.js",
                "\u2502   \u2502   \u251c\u2500\u2500 lessons",
                "\u2502   \u2502   \u2502   \u251c\u2500\u2500 lessonsController.js",
                "\u2502   \u2502   \u251c\u2500\u2500 resources",
                "\u2502   \u2502       \u251c\u2500\u2500 resourcesController.js",
                "\u2502   \u251c\u2500\u2500 routes",
                "\u2502   \u2502   \u251c\u2500\u2500 dictionaryRoutes.js",
                "\u2502   \u2502   \u251c\u2500\u2500 wordOfTheDayRoutes.js",
                "\u2502   \u2502   \u251c\u2500\u2500 aiRoutes.js",
                "\u2502   \u2502   \u251c\u2500\u2500 commentsRoutes.js",
                "\u2502   \u2502   \u251c\u2500\u2500 games",
                "\u2502   \u2502   \u2502   \u251c\u2500\u2500 gamesRoutes.js",
                "\u2502   \u2502   \u251c\u2500\u2500 lessons",
                "\u2502   \u2502   \u2502   \u251c\u2500\u2500 lessonsRoutes.js",
                "\u2502   \u2502   \u251c\u2500\u2500 resources",
                "\u2502   \u2502       \u251c\u2500\u2500 resourcesRoutes.js",
                "\u2502   \u251c\u2500\u2500 services",
                "\u2502   \u2502   \u251c\u2500\u2500 dictionaryService.js",
                "\u2502   \u2502   \u251c\u2500\u2500 wordOfTheDayService.js",
                "\u2502   \u2502   \u251c\u2500\u2500 aiService.js",
                "\u2502   \u2502   \u251c\u2500\u2500 commentsService.js",
                "\u2502   \u2502   \u251c\u2500\u2500 games",
                "\u2502   \u2502   \u2502   \u251c\u2500\u2500 gamesService.js",
                "\u2502   \u2502   \u251c\u2500\u2500 lessons",
                "\u2502   \u2502   \u2502   \u251c\u2500\u2500 lessonsService.js",
                "\u2502   \u2502   \u251c\u2500\u2500 resources",
                "\u2502   \u2502       \u251c\u2500\u2500 resourcesService.js",
                "\u2502   \u251c\u2500\u2500 app.js",
                "\u2502   \u251c\u2500\u2500 server.js",
                "\u251c\u2500\u2500 .env",
                "",
                "## API Endpoints",
                "",
                "### Dictionary Routes",
                "",
                "- `GET /api/dictionary` - Retrieve the entire dictionary.",
                "- `GET /api/word-details?word={word}` - Retrieve details for a specific word.",
                "",
                "### Word of the Day Routes",
                "",
                "- `GET /api/word-of-the-day` - Retrieve the word of the day.",
                "- `PUT /api/word-of-the-day/update` - Update the word of the day.",
                "",
                "### AI Routes",
                "",
                "- `GET /api/fact?word={word}` - Retrieve an AI-generated fact about a word.",
                "",
                "### Comments Routes",
                "",
                "- `GET /api/comments?word_id={word_id}` - Retrieve comments for a specific word.",
                "- `POST /api/comments` - Add a new comment.",
                "",
                "## Client-side Code",
                "",
                "### `client/js/index.js`",
                "",
                "Placeholder for index-specific JavaScript if needed.",
                "",
                "### `client/js/wordOfTheDay.js`",
                "",
                "- Fetches and displays the word of the day.",
                "",
                "### `client/js/dictionary.js`",
                "",
                "- Handles dictionary search and filtering.",
                "- Fetches and displays dictionary data.",
                "- Implements pagination for dictionary entries.",
                "",
                "### `client/js/word-details.js`",
                "",
                "- Fetches and displays details for a specific word.",
                "- Fetches and displays comments for a word.",
                "- Handles adding new comments and replies.",
                "",
                "## Server-side Code",
                "",
                "### `server/app.js`",
                "",
                "- Sets up the Express application, middleware, and routes.",
                "",
                "### `server/server.js`",
                "",
                "- Starts the server on the specified port.",
                "",
                "### `server/config/database.js`",
                "",
                "- Configures and exports the Supabase client for database interactions.",
                "",
                "### `server/config/openai.js`",
                "",
                "- Configures and exports the OpenAI client for AI interactions.",
                "",
                "## Controllers",
                "",
                "- `dictionaryController.js` - Handles dictionary-related API requests.",
                "- `wordOfTheDayController.js` - Handles word of the day API requests.",
                "- `aiController.js` - Handles AI-related API requests.",
                "- `commentsController.js` - Handles comment-related API requests.",
                "- `games/gamesController.js` - Handles game-related API requests.",
                "- `lessons/lessonsController.js` - Handles lesson-related API requests.",
                "- `resources/resourcesController.js` - Handles resource-related API requests.",
                "",
                "## Services",
                "",
                "- `dictionaryService.js` - Provides dictionary data operations.",
                "- `wordOfTheDayService.js` - Provides word of the day data operations.",
                "- `aiService.js` - Provides AI-related operations.",
                "- `commentsService.js` - Provides comment-related operations.",
                "- `games/gamesService.js` - Provides game-related operations.",
                "- `lessons/lessonsService.js` - Provides lesson-related operations.",
                "- `resources/resourcesService.js` - Provides resource-related operations.",
                "",
                "## Contributing",
                "",
                "If you would like to contribute, please fork the repository and submit a pull request. For major changes, please open an issue to discuss what you would like to change.",
                "",
                "## License",
                "",
                "This project is licensed under the MIT License. See the [LICENSE.md](LICENSE.md) file for details."
            ],
            "notes": [
                "Keep the README.md updated to reflect any changes in the project structure, setup, and usage instructions. This helps maintain clarity and ensures that contributors and users have the most current information."
            ]
        }
    },
    {
        "id": "5",
        "name": "package.json",
        "path": "package.json",
        "description": "Contains the project's dependencies and scripts.",
        "details": {
            "purpose": "Defines project metadata and dependencies for Node.js.",
            "content": {
                "name": "migmag_foundation",
                "version": "1.0.0",
                "main": "index.js",
                "scripts": {
                    "build:tailwind": "tailwindcss -i client/css/input.css -o client/css/output.css --watch",
                    "start": "node server/server.js"
                },
                "keywords": [],
                "author": "",
                "license": "ISC",
                "description": "",
                "dependencies": {
                    "@supabase/supabase-js": "^2.44.3",
                    "@vercel/speed-insights": "^1.0.12",
                    "axios": "^1.7.2",
                    "cors": "^2.8.5",
                    "cron": "^3.1.7",
                    "dotenv": "^16.4.5",
                    "express": "^4.19.2",
                    "fuse.js": "^7.0.0",
                    "node": "^22.3.0",
                    "node-cron": "^3.0.3",
                    "nodemon": "^3.1.3",
                    "openai": "^4.52.3",
                    "vercel": "^34.3.1"
                },
                "devDependencies": {
                    "tailwindcss": "^3.4.4"
                }
            },
            "notes": [
                "Ensure to keep the dependencies and scripts updated as per project requirements."
            ]
        }
    },
    {
        "id": "6",
        "name": "package-lock.json",
        "path": "package-lock.json",
        "description": "Contains the exact versions of dependencies.",
        "details": {
            "purpose": "Ensures consistent dependency versions across installations.",
            "content": [
                "null"
            ],
            "notes": [
                "Do not manually edit this file. It is automatically generated."
            ]
        }
    },
    {
        "id": "7",
        "name": "tailwind.config.js",
        "path": "tailwind.config.js",
        "description": "Tailwind CSS configuration file.",
        "details": {
            "purpose": "Configures the Tailwind CSS framework for the project.",
            "content": [
                "/** @type {import('tailwindcss').Config} */",
                "module.exports = {",
                "  content: ['./client/**/*.html', './client/**/*.js'], // Update this to match all relevant files",
                "  theme: {",
                "    extend: {",
                "      fontFamily: {",
                "        sans: ['Noto Sans', 'sans-serif'], // This sets Noto Sans as the default sans-serif font",
                "      },",
                "    },",
                "  },",
                "  plugins: [],",
                "}"
            ],
            "notes": [
                "Ensure the 'content' paths are correctly set to include all HTML and JS files within the client directory. This configuration helps Tailwind CSS to properly purge unused styles, leading to optimized CSS output. Customize the 'theme.extend' section as needed to fit the project's design requirements."
            ]
        }
    },
    {
        "id": "8",
        "name": "vercel.json",
        "path": "vercel.json",
        "description": "Vercel deployment configuration file.",
        "details": {
            "purpose": "Configures the deployment settings for Vercel.",
            "content": {
                "version": 2,
                "builds": [
                    {
                        "src": "server/server.js",
                        "use": "@vercel/node"
                    },
                    {
                        "src": "client/**/*",
                        "use": "@vercel/static"
                    }
                ],
                "routes": [
                    {
                        "src": "/api/(.*)",
                        "dest": "/server/server.js"
                    },
                    {
                        "src": "/dictionary",
                        "dest": "/client/pages/dictionary.html"
                    },
                    {
                        "src": "/education",
                        "dest": "/client/pages/education.html"
                    },
                    {
                        "src": "/word-details",
                        "dest": "/client/pages/word-details.html"
                    },
                    {
                        "src": "/",
                        "dest": "/client/pages/index.html"
                    },
                    {
                        "src": "/css/(.*)",
                        "dest": "/client/css/$1"
                    },
                    {
                        "src": "/js/(.*)",
                        "dest": "/client/js/$1"
                    },
                    {
                        "src": "/assets/(.*)",
                        "dest": "/client/assets/$1"
                    },
                    {
                        "src": "/(.*)",
                        "dest": "/client/pages/$1"
                    }
                ]
            },
            "notes": [
                "Ensure the paths and routes match the project's structure."
            ]
        }
    },
    {
        "id": "9",
        "name": "input.css",
        "path": "client/css/input.css",
        "description": "Tailwind CSS input file.",
        "details": {
            "purpose": "Contains the base, components, and utilities from Tailwind CSS along with custom styles.",
            "content": [
                "@tailwind base;",
                "@tailwind components;",
                "@tailwind utilities;"
            ],
            "notes": [
                "Tailwind CSS input file with area to add styles custom styles."
            ]
        }
    },
    {
        "id": "10",
        "name": "output.css",
        "path": "client/css/output.css",
        "description": "Tailwind CSS output file.",
        "details": {
            "purpose": "Generated CSS file from Tailwind CSS with custom styles.",
            "content": [
                "null"
            ],
            "notes": [
                "This file is generated by Tailwind CSS based on the input.css file."
            ]
        }
    },
    {
        "id": "11",
        "name": "dictionary.js",
        "path": "client/js/dictionary.js",
        "description": "JavaScript file for the dictionary functionality.",
        "details": {
            "purpose": "Handles searching, filtering, and displaying dictionary words.",
            "content": [
                "document.addEventListener('DOMContentLoaded', function() {",
                "    // Get references to DOM elements",
                "    const searchInput = document.getElementById('searchInput');",
                "    const searchButton = document.getElementById('searchButton');",
                "    const filterSelect = document.getElementById('filterSelect');",
                "    const dictionaryContainer = document.getElementById('dictionary-container');",
                "    const alphabetContainer = document.getElementById('alphabet-container');",
                "    const paginationContainer = document.getElementById('pagination-container');",
                "    const instructionsModal = document.getElementById('instructionsModal');",
                "    const themeToggle = document.getElementById('theme-toggle');",
                "    const instructionsIconLight = document.getElementById('instructionsIconLight');",
                "    const instructionsIconDark = document.getElementById('instructionsIconDark');",
                "    const closeButton = document.querySelector('.modal-close-button');",
                "",
                "    // Define alphabet for navigation",
                "    const alphabet = 'AEGIJLMNOPQSTUW';",
                "    let currentPage = 1; // Current page for pagination",
                "    const itemsPerPage = 20; // Items per page for pagination",
                "    let currentFilter = ''; // Current filter for search",
                "    let currentTerm = ''; // Current search term",
                "    let dictionaryData = []; // Full dictionary data",
                "    let filteredData = []; // Filtered dictionary data",
                "    let fuse; // Fuse.js instance for searching",
                "",
                "    // Initialize the application",
                "    initialize();",
                "",
                "    function initialize() {",
                "        populateAlphabetContainer(); // Populate alphabet navigation",
                "        addEventListeners(); // Add event listeners",
                "        fetchFullDictionaryData(); // Fetch dictionary data",
                "        applyTheme(); // Apply the current theme",
                "    }",
                "",
                "    // Populate alphabet navigation container",
                "    function populateAlphabetContainer() {",
                "        alphabet.split('').forEach(letter => {",
                "            const letterSpan = document.createElement('span');",
                "            letterSpan.textContent = letter;",
                "            letterSpan.className = 'border border-gray-300 w-14 h-14 flex items-center justify-center text-4xl cursor-pointer rounded-md m-2 hover:bg-gray-400 dark:hover:bg-gray-300';",
                "            letterSpan.addEventListener('click', () => filterByLetter(letter));",
                "            alphabetContainer.appendChild(letterSpan);",
                "        });",
                "    }",
                "",
                "    // Add event listeners for search, theme toggle, and instructions modal",
                "    function addEventListeners() {",
                "        searchButton.addEventListener('click', () => searchDictionary());",
                "        searchInput.addEventListener('keydown', function(event) {",
                "            if (event.key === 'Enter') {",
                "                event.preventDefault();",
                "                searchDictionary();",
                "            }",
                "        });",
                "",
                "        themeToggle.addEventListener('click', () => {",
                "            document.body.classList.toggle('dark-mode');",
                "            applyTheme();",
                "        });",
                "",
                "        instructionsIconLight.addEventListener('click', () => toggleInstructionsModal(true));",
                "        instructionsIconDark.addEventListener('click', () => toggleInstructionsModal(true));",
                "        closeButton.addEventListener('click', () => toggleInstructionsModal(false));",
                "",
                "        window.addEventListener('click', (event) => {",
                "            if (event.target === instructionsModal) {",
                "                toggleInstructionsModal(false);",
                "            }",
                "        });",
                "    }",
                "",
                "    // Fetch the full dictionary data from the server",
                "    function fetchFullDictionaryData() {",
                "        fetch('/api/dictionary')",
                "            .then(response => response.json())",
                "            .then(data => {",
                "                dictionaryData = data || [];",
                "                initializeFuse(dictionaryData);",
                "                filteredData = dictionaryData;",
                "                displayDictionary(filteredData);",
                "                createPagination(filteredData.length);",
                "            })",
                "            .catch(error => {",
                "                console.error('Error fetching dictionary data:', error);",
                "                displayError('Error fetching dictionary data. Please try again later.');",
                "            });",
                "    }",
                "",
                "    // Initialize Fuse.js for searching",
                "    function initializeFuse(words) {",
                "        const fuseOptions = {",
                "            keys: [",
                "                'word',",
                "                { name: 'usages.translation', weight: 0.5 },",
                "                { name: 'usages.english', weight: 0.5 },",
                "                'type',",
                "                'definitions'",
                "            ],",
                "            threshold: 0.4,",
                "        };",
                "        fuse = new Fuse(words, fuseOptions);",
                "    }",
                "",
                "    // Search the dictionary based on the current term and filter",
                "    function searchDictionary() {",
                "        currentTerm = searchInput.value.trim();",
                "        currentFilter = filterSelect.value;",
                "        if (currentTerm) {",
                "            let result = [];",
                "            switch (currentFilter) {",
                "                case 'word':",
                "                    result = fuse.search(currentTerm).filter(item =>",
                "                        item.item.word.toLowerCase().includes(currentTerm.toLowerCase()) ||",
                "                        (item.item.usages && item.item.usages.some(usage => usage.translation.toLowerCase().includes(currentTerm.toLowerCase())))",
                "                    );",
                "                    break;",
                "                case 'translations_mi':",
                "                    result = fuse.search(currentTerm).filter(item =>",
                "                        (item.item.usages && item.item.usages.some(usage => usage.translation.toLowerCase().includes(currentTerm.toLowerCase()))) ||",
                "                        item.item.word.toLowerCase().includes(currentTerm.toLowerCase())",
                "                    );",
                "                    break;",
                "                case 'translations_en':",
                "                    result = fuse.search(currentTerm).filter(item =>",
                "                        (item.item.usages && item.item.usages.some(usage => usage.english.toLowerCase().includes(currentTerm.toLowerCase()))) ||",
                "                        (item.item.definitions && item.item.definitions.some(def => def.toLowerCase().includes(currentTerm.toLowerCase())))",
                "                    );",
                "                    break;",
                "                case 'definitions':",
                "                    result = fuse.search(currentTerm).filter(item =>",
                "                        (item.item.definitions && item.item.definitions.some(def => def.toLowerCase().includes(currentTerm.toLowerCase()))) ||",
                "                        (item.item.usages && item.item.usages.some(usage => usage.english.toLowerCase().includes(currentTerm.toLowerCase())))",
                "                    );",
                "                    break;",
                "                case 'type':",
                "                    result = fuse.search(currentTerm).filter(item => item.item.type.toLowerCase().includes(currentTerm.toLowerCase()));",
                "                    break;",
                "                default:",
                "                    result = fuse.search(currentTerm);",
                "                    break;",
                "            }",
                "            filteredData = result.map(r => r.item);",
                "        } else {",
                "            filteredData = dictionaryData;",
                "        }",
                "",
                "        if (filteredData.length === 0) {",
                "            displayError('No results found. Please check your filter and try again.');",
                "        } else {",
                "            currentPage = 1;",
                "            displayDictionary(filteredData);",
                "            createPagination(filteredData.length);",
                "        }",
                "    }",
                "",
                "    // Filter dictionary by letter",
                "    function filterByLetter(letter) {",
                "        currentTerm = letter;",
                "        currentFilter = 'startsWith';",
                "        filteredData = dictionaryData.filter(word => word.word.toLowerCase().startsWith(letter.toLowerCase()));",
                "        if (filteredData.length === 0) {",
                "            displayError('No results found. Please check your filter and try again.');",
                "        } else {",
                "            currentPage = 1;",
                "            displayDictionary(filteredData);",
                "            createPagination(filteredData.length);",
                "        }",
                "    }",
                "",
                "    // Display the dictionary words on the page",
                "    function displayDictionary(words) {",
                "        dictionaryContainer.innerHTML = '';",
                "        if (words.length === 0) {",
                "            displayError('No results found. Please check your filter and try again.');",
                "            return;",
                "        }",
                "",
                "        const paginatedWords = words.slice((currentPage - 1) * itemsPerPage, currentPage * itemsPerPage);",
                "",
                "        paginatedWords.forEach(word => {",
                "            const wordDiv = document.createElement('div');",
                "            wordDiv.classList.add('word-item', 'min-h-[10rem]', 'border', 'border-gray-300', 'rounded-lg', 'p-10', 'mb-4', 'transition', 'duration-300');",
                "",
                "            wordDiv.innerHTML = `",
                "                <a href=\"/word-details.html?word=${encodeURIComponent(word.word)}\" class=\"block p-6\">",
                "                    <h2 class=\"text-xl font-semibold mb-4\">${word.word}</h2>",
                "                    <div class=\"mb-4\">",
                "                        <strong class=\"block mb-2\">Part of Speech:</strong>",
                "                        <span class=\"block\">${word.type}</span>",
                "                    </div>",
                "                    <div class=\"mb-4\">",
                "                        <strong class=\"block mb-2\">English Definitions:</strong>",
                "                        <ul class=\"list-disc list-inside\">",
                "                            ${word.definitions.map(def => `<li>${def}</li>`).join('')}",
                "                        </ul>",
                "                    </div>",
                "                    <div>",
                "                        <strong class=\"block mb-2\">Translations:</strong>",
                "                        <ul>",
                "                            ${word.usages.map(usage => `",
                "                                <li>",
                "                                    <strong>Mi'gmaq Translation:</strong> ${usage.translation}<br>",
                "                                    <strong>English Translation:</strong> ${usage.english}",
                "                                </li>",
                "                            `).join('')}",
                "                        </ul>",
                "                    </div>",
                "                </a>",
                "            `;",
                "            wordDiv.addEventListener('mouseover', () => applyHoverEffect(wordDiv, true));",
                "            wordDiv.addEventListener('mouseout', () => applyHoverEffect(wordDiv, false));",
                "            dictionaryContainer.appendChild(wordDiv);",
                "        });",
                "",
                "        applyTheme(); // Ensure dark mode classes are applied after appending new elements",
                "    }",
                "",
                "    // Create pagination controls",
                "    function createPagination(totalItems) {",
                "        const totalPages = Math.ceil(totalItems / itemsPerPage);",
                "        paginationContainer.innerHTML = '';",
                "",
                "        paginationContainer.appendChild(createPaginationButton('Previous', currentPage > 1, currentPage - 1));",
                "",
                "        const pageInput = document.createElement('input');",
                "        pageInput.type = 'number';",
                "        pageInput.min = 1;",
                "        pageInput.max = totalPages;",
                "        pageInput.value = currentPage;",
                "        pageInput.className = 'px-3 py-1 bg-gray-100 dark:bg-gray-800 text-gray-900 dark:text-white rounded-md mx-2 w-16 text-center';",
                "        pageInput.addEventListener('change', () => {",
                "            const pageNumber = parseInt(pageInput.value);",
                "            if (pageNumber >= 1 && pageNumber <= totalPages) {",
                "                currentPage = pageNumber;",
                "                displayDictionary(filteredData);",
                "                createPagination(filteredData.length);",
                "            } else {",
                "                alert(`Please enter a valid page number between 1 and ${totalPages}.`);",
                "            }",
                "        });",
                "        paginationContainer.appendChild(pageInput);",
                "",
                "        const totalPagesLabel = document.createElement('span');",
                "        totalPagesLabel.textContent = `of ${totalPages}`;",
                "        totalPagesLabel.className = 'text-gray-900 dark:text-white mx-2';",
                "        paginationContainer.appendChild(totalPagesLabel);",
                "",
                "        paginationContainer.appendChild(createPaginationButton('Next', currentPage < totalPages, currentPage + 1));",
                "",
                "        applyTheme();",
                "    }",
                "",
                "    // Create a pagination button",
                "    function createPaginationButton(text, enabled, page) {",
                "        const button = document.createElement('button');",
                "        button.textContent = text;",
                "        button.className = 'px-3 py-1 bg-gray-100 dark:bg-gray-800 text-gray-900 dark:text-white rounded-md mx-2 hover:bg-gray-300 dark:hover:bg-gray-600';",
                "        button.disabled = !enabled;",
                "        if (enabled) {",
                "            button.addEventListener('click', () => {",
                "                currentPage = page;",
                "                displayDictionary(filteredData);",
                "                createPagination(filteredData.length);",
                "            });",
                "        }",
                "        return button;",
                "    }",
                "",
                "    // Apply the current theme (dark or light)",
                "    function applyTheme() {",
                "        const isDarkMode = document.body.classList.contains('dark-mode');",
                "        document.querySelectorAll('.word-item').forEach(item => {",
                "            item.style.backgroundColor = isDarkMode ? '#2d3748' : '#f7fafc';",
                "            item.style.color = isDarkMode ? '#ffffff' : '#1a202c';",
                "        });",
                "        document.querySelectorAll('a.block').forEach(link => {",
                "            link.style.color = isDarkMode ? '#ffffff' : '#1a202c';",
                "        });",
                "        document.querySelectorAll('.pagination button').forEach(button => {",
                "            button.style.backgroundColor = isDarkMode ? '#2d3748' : '#f7fafc';",
                "            button.style.color = isDarkMode ? '#ffffff' : '#1a202c';",
                "        });",
                "        // Apply dark mode to search input and filter select",
                "        searchInput.style.backgroundColor = isDarkMode ? '#2d3748' : '#f7fafc';",
                "        searchInput.style.color = isDarkMode ? '#ffffff' : '#1a202c';",
                "        filterSelect.style.backgroundColor = isDarkMode ? '#2d3748' : '#f7fafc';",
                "        filterSelect.style.color = isDarkMode ? '#ffffff' : '#1a202c';",
                "        // Apply dark mode to pagination label",
                "        const totalPagesLabel = document.querySelector('.pagination span');",
                "        if (totalPagesLabel) {",
                "            totalPagesLabel.style.color = isDarkMode ? '#ffffff' : '#1a202c';",
                "        }",
                "",
                "        // Toggle icon visibility based on theme",
                "        if (isDarkMode) {",
                "            instructionsIconLight.classList.add('hidden');",
                "            instructionsIconDark.classList.remove('hidden');",
                "        } else {",
                "            instructionsIconLight.classList.remove('hidden');",
                "            instructionsIconDark.classList.add('hidden');",
                "        }",
                "",
                "        // Apply dark or light mode to the close button",
                "        if (closeButton) {",
                "            if (isDarkMode) {",
                "                closeButton.classList.remove('light-mode');",
                "            } else {",
                "                closeButton.classList.add('light-mode');",
                "            }",
                "        }",
                "    }",
                "",
                "    // Apply hover effect for word items",
                "    function applyHoverEffect(element, isHover) {",
                "        const isDarkMode = document.body.classList.contains('dark-mode');",
                "        element.style.backgroundColor = isHover ",
                "            ? (isDarkMode ? '#4a5568' : '#e2e8f0') ",
                "            : (isDarkMode ? '#2d3748' : '#f7fafc');",
                "    }",
                "",
                "    // Display an error message",
                "    function displayError(message) {",
                "        dictionaryContainer.innerHTML = `<p class='error text-gray-500 text-center dark:text-white'>${message}</p>`;",
                "    }",
                "",
                "    // Toggle instructions modal",
                "    function toggleInstructionsModal(show) {",
                "        if (show) {",
                "            instructionsModal.classList.add('active');",
                "            document.body.style.overflow = 'hidden'; // Prevent background scrolling",
                "        } else {",
                "            instructionsModal.classList.remove('active');",
                "            document.body.style.overflow = 'auto'; // Re-enable background scrolling",
                "        }",
                "    }",
                "});"
            ],
            "notes": [
                "This file contains the core logic for managing the dictionary feature of the application, including search, filtering, and pagination. Ensure the paths to the elements in the HTML structure match those referenced in this script."
            ]
        }
    },
    {
        "id": "12",
        "name": "documentation.js",
        "path": "client/js/documentation.js",
        "description": "JavaScript file for handling documentation page.",
        "details": {
            "purpose": "Fetches project structure JSON and displays it on the documentation page.",
            "content": [
                "document.addEventListener('DOMContentLoaded', function() {",
                "    fetchProjectStructure();",
                "",
                "    document.getElementById('searchInput').addEventListener('keyup', searchFunction);",
                "    initializeResizer();",
                "});",
                "",
                "function fetchProjectStructure() {",
                "    fetch('../assets/documentation.json')",
                "        .then(response => response.json())",
                "        .then(data => renderProjectStructure(data))",
                "        .catch(error => console.error('Error loading JSON:', error));",
                "}",
                "",
                "function renderProjectStructure(data) {",
                "    const documentationContainer = document.getElementById('documentation');",
                "    documentationContainer.innerHTML = '';",
                "    data.forEach(item => {",
                "        documentationContainer.appendChild(createNode(item));",
                "    });",
                "}",
                "",
                "function createNode(item) {",
                "    const element = document.createElement('div');",
                "    element.className = item.children ? 'directory' : 'file';",
                "    element.setAttribute('data-name', item.name.toLowerCase());",
                "    element.setAttribute('data-description', item.description.toLowerCase());",
                "",
                "    const header = document.createElement('div');",
                "    header.textContent = item.name;",
                "    header.className = 'cursor-pointer';",
                "    element.appendChild(header);",
                "",
                "    if (item.children) {",
                "        const childrenContainer = createChildrenContainer(item.children);",
                "        element.appendChild(childrenContainer);",
                "        header.addEventListener('click', () => {",
                "            childrenContainer.style.display = childrenContainer.style.display === 'none' ? 'block' : 'none';",
                "        });",
                "    } else {",
                "        header.addEventListener('click', () => {",
                "            displayDetails(item);",
                "        });",
                "    }",
                "",
                "    return element;",
                "}",
                "",
                "function createChildrenContainer(children) {",
                "    const childrenContainer = document.createElement('div');",
                "    childrenContainer.className = 'children';",
                "    children.forEach(child => {",
                "        childrenContainer.appendChild(createNode(child));",
                "    });",
                "    return childrenContainer;",
                "}",
                "",
                "function displayDetails(item) {",
                "    const mainContent = document.getElementById('mainContent');",
                "    mainContent.innerHTML = `",
                "        <h2>${item.name}</h2>",
                "        <p><strong>Description:</strong> ${item.description}</p>",
                "        <p><strong>Purpose:</strong> ${item.details.purpose}</p>",
                "        <div class=\"details\">",
                "            <p><strong>Content:</strong></p>",
                "            <pre>${typeof item.details.content === 'object' ",
                "                ? JSON.stringify(item.details.content, null, 2) ",
                "                : item.details.content.replace(/\\n/g, '<br>').replace(/ /g, '&nbsp;')}",
                "            </pre>",
                "            <p><strong>Notes:</strong> ${item.details.notes}</p>",
                "        </div>",
                "    `;",
                "}",
                "",
                "function searchFunction() {",
                "    const input = document.getElementById('searchInput').value.toLowerCase();",
                "    const elements = document.querySelectorAll('#documentation .directory, #documentation .file');",
                "",
                "    elements.forEach(element => {",
                "        const name = element.getAttribute('data-name');",
                "        const description = element.getAttribute('data-description');",
                "        if (name.includes(input) || description.includes(input)) {",
                "            element.classList.remove('hidden');",
                "        } else {",
                "            element.classList.add('hidden');",
                "        }",
                "    });",
                "}",
                "",
                "function initializeResizer() {",
                "    const resizer = document.getElementById('resizer');",
                "    const sidebar = document.getElementById('sidebar');",
                "    let isResizing = false;",
                "",
                "    resizer.addEventListener('mousedown', (e) => {",
                "        isResizing = true;",
                "        document.addEventListener('mousemove', resizeSidebar);",
                "        document.addEventListener('mouseup', stopResizing);",
                "    });",
                "",
                "    function resizeSidebar(e) {",
                "        if (!isResizing) return;",
                "        const newWidth = e.clientX;",
                "        if (newWidth >= 200 && newWidth <= 400) {",
                "            sidebar.style.width = newWidth + 'px';",
                "        }",
                "    }",
                "",
                "    function stopResizing() {",
                "        isResizing = false;",
                "        document.removeEventListener('mousemove', resizeSidebar);",
                "        document.removeEventListener('mouseup', stopResizing);",
                "    }",
                "}",
                ""
            ],
            "notes": [
                "This JavaScript file manages the documentation page by fetching and rendering the project structure from a JSON file. It includes functions for dynamic creation of documentation nodes, search functionality to filter displayed nodes, and a resizer for the sidebar. Ensure the project structure JSON is correctly formatted and the required DOM elements are present in the HTML."
            ]
        }
    },
    {
        "id": "13",
        "name": "index.js",
        "path": "client/js/index.js",
        "description": "Main JavaScript file for the homepage.",
        "details": {
            "purpose": "Handles theme toggling and other homepage functionalities.",
            "content": [
                "document.addEventListener('DOMContentLoaded', function() {",
                "    const themeToggle = document.getElementById('theme-toggle');",
                "    const body = document.body;",
                "",
                "    themeToggle.addEventListener('click', () => {",
                "        body.classList.toggle('dark-mode');",
                "        body.classList.toggle('light-mode');",
                "        applyTheme();",
                "    });",
                "",
                "    function applyTheme() {",
                "        const isDarkMode = body.classList.contains('dark-mode');",
                "        document.querySelectorAll('.section').forEach(section => {",
                "            section.style.backgroundColor = isDarkMode ? '#1a202c' : '#ffffff';",
                "            section.style.color = isDarkMode ? '#f9f9f9' : '#000000';",
                "        });",
                "    }",
                "",
                "    applyTheme(); // Apply the initial theme",
                "});"
            ],
            "notes": [
                "Includes event listeners for theme toggling and functions to apply the current theme."
            ]
        }
    },
    {
        "id": "14",
        "name": "word-details.js",
        "path": "client/js/word-details.js",
        "description": "JavaScript file for displaying word details.",
        "details": {
            "purpose": "Fetches and displays detailed information for a specific word.",
            "content": [
                "document.addEventListener('DOMContentLoaded', function() {",
                "    const queryParams = new URLSearchParams(window.location.search);",
                "    const word = queryParams.get('word'); // Get the 'word' query parameter from the URL",
                "",
                "    if (!word) {",
                "        console.error('No word parameter found in URL.');",
                "        return;",
                "    }",
                "",
                "    // Get references to various HTML elements",
                "    const wordDetailsContainer = document.getElementById('word-details-container');",
                "    const aiFactContainer = document.getElementById('ai-fact-container');",
                "    const commentsContainer = document.getElementById('comments-container');",
                "    const commentForm = document.getElementById('comment-form');",
                "    const wordIdInput = document.getElementById('word_id');",
                "    const parentIdInput = document.getElementById('parent_id');",
                "",
                "    if (word) {",
                "        wordIdInput.value = word; // Set the wordId input value",
                "    }",
                "",
                "    // Fetch and display word details and comments",
                "    Promise.all([",
                "        fetchWordDetails(word),",
                "        fetchComments(word)",
                "    ]).finally(() => {",
                "        // Hide preloader after word details and comments are loaded",
                "        const preloader = document.getElementById('preloader');",
                "        preloader.style.display = 'none';",
                "        ",
                "        // Fetch AI fact after main content is loaded",
                "        fetchWordDetails(word).then(wordDetails => {",
                "            const type = wordDetails.type;",
                "            const translations = wordDetails.usages.map(usage => usage.translation).join(', ');",
                "            const definitions = wordDetails.definitions.join(', ');",
                "            fetchAiFact(word, type, translations, definitions);",
                "        });",
                "    });",
                "",
                "    // Add event listeners for comment form and reply button clicks",
                "    commentForm.addEventListener('submit', handleCommentSubmit);",
                "    commentsContainer.addEventListener('click', handleReplyButtonClick);",
                "    commentsContainer.addEventListener('submit', handleReplyFormSubmit);",
                "",
                "    // Add event listener for theme toggle",
                "    const themeToggle = document.getElementById('theme-toggle');",
                "    themeToggle.addEventListener('click', () => {",
                "        document.body.classList.toggle('dark-mode');",
                "        document.body.classList.toggle('light-mode');",
                "        applyTheme();",
                "    });",
                "",
                "    applyTheme(); // Apply the initial theme",
                "",
                "    // Function to fetch word details from the server",
                "    function fetchWordDetails(word) {",
                "        return fetch(`/api/word-details?word=${encodeURIComponent(word)}`)",
                "            .then(response => response.json())",
                "            .then(wordDetails => {",
                "                displayWordDetails(wordDetails);",
                "                return wordDetails;",
                "            })",
                "            .catch(error => {",
                "                console.error('Error fetching word details:', error);",
                "                displayError();",
                "            });",
                "    }",
                "",
                "    // Function to fetch AI fact from the server",
                "    function fetchAiFact(word, type, translations, definitions) {",
                "        return fetch(`/api/fact?word=${encodeURIComponent(word)}&type=${encodeURIComponent(type)}&translations=${encodeURIComponent(translations)}&definitions=${encodeURIComponent(definitions)}`)",
                "            .then(response => response.json())",
                "            .then(data => displayAiFact(data.fact))",
                "            .catch(error => {",
                "                console.error('Error fetching AI fact:', error);",
                "                aiFactContainer.innerHTML = '<p class=\"error text-white-500 text-center\">Error fetching AI fact. Please try again later.</p>';",
                "            });",
                "    }",
                "",
                "    // Function to display word details in the HTML",
                "    function displayWordDetails(wordDetails) {",
                "        const wordHTML = `",
                "            <div class=\"word-item rounded-md\">",
                "                <h2 class=\"text-3xl font-bold mb-6 text-center\">${wordDetails.word}</h2>",
                "                <div class=\"mb-6\">",
                "                    <strong class=\"block text-xl mb-3\">Part of Speech:</strong>",
                "                    <span class=\"block text-lg\">${wordDetails.type}</span>",
                "                </div>",
                "                <div class=\"mb-6\">",
                "                    <strong class=\"block text-xl mb-3\">English Definitions:</strong>",
                "                    <ul class=\"list-disc list-inside text-lg\">",
                "                        ${wordDetails.definitions.map(def => `<li>${def}</li>`).join('')}",
                "                    </ul>",
                "                </div>",
                "                <div class=\"mb-6\">",
                "                    <strong class=\"block text-xl mb-3\">Translations:</strong>",
                "                    <ul class=\"text-lg\">",
                "                        ${wordDetails.usages.map(usage => `",
                "                            <li class=\"mb-4\">",
                "                                <strong>Mi'gmaq Translation:</strong> ${usage.translation}<br>",
                "                                <strong>English Translation:</strong> ${usage.english}",
                "                            </li>",
                "                        `).join('')}",
                "                    </ul>",
                "                </div>",
                "            </div>",
                "        `;",
                "        wordDetailsContainer.innerHTML = wordHTML;",
                "        applyTheme(); // Apply theme to newly added elements",
                "    }",
                "",
                "    // Function to display AI fact in the HTML",
                "    function displayAiFact(fact) {",
                "        aiFactContainer.innerHTML = `<p class=\"text-2xl font-medium text-center\">${fact}</p>`;",
                "        applyTheme(); // Apply theme to newly added elements",
                "    }",
                "",
                "    // Function to display an error message",
                "    function displayError() {",
                "        wordDetailsContainer.innerHTML = '<p class=\"error text-white-500 text-center\">Error fetching word details. Please try again later.</p>';",
                "    }",
                "",
                "    // Function to fetch comments from the server",
                "    function fetchComments(wordId) {",
                "        return fetch(`/api/comments?word_id=${encodeURIComponent(wordId)}`)",
                "            .then(response => response.json())",
                "            .then(comments => {",
                "                commentsContainer.innerHTML = ''; // Clear previous comments",
                "                const nestedComments = buildNestedComments(comments);",
                "                displayComments(nestedComments);",
                "            })",
                "            .catch(error => {",
                "                console.error('Error fetching comments:', error);",
                "                commentsContainer.innerHTML = '<p class=\"error text-white-500 text-center\">Error fetching comments. Please try again later.</p>';",
                "            });",
                "    }",
                "",
                "    // Function to build nested comments structure",
                "    function buildNestedComments(comments) {",
                "        const commentMap = {};",
                "        comments.forEach(comment => {",
                "            comment.replies = [];",
                "            commentMap[comment.id] = comment;",
                "        });",
                "",
                "        const nestedComments = [];",
                "        comments.forEach(comment => {",
                "            if (comment.parent_id) {",
                "                commentMap[comment.parent_id].replies.push(comment);",
                "            } else {",
                "                nestedComments.push(comment);",
                "            }",
                "        });",
                "",
                "        return nestedComments;",
                "    }",
                "",
                "    // Function to display comments in the HTML",
                "    function displayComments(comments, parentElement = null, level = 0) {",
                "        const commentsList = parentElement || document.createElement('ul');",
                "        if (!parentElement) commentsContainer.appendChild(commentsList);",
                "",
                "        comments.forEach(comment => {",
                "            const commentItem = createCommentItem(comment, level);",
                "            commentsList.appendChild(commentItem);",
                "            if (comment.replies.length > 0) {",
                "                const replyList = document.createElement('ul');",
                "                commentItem.appendChild(replyList);",
                "                displayComments(comment.replies, replyList, level + 1);",
                "            }",
                "        });",
                "        applyTheme(); // Apply theme to newly added elements",
                "    }",
                "",
                "    // Function to create a comment item in the HTML",
                "    function createCommentItem(comment, level) {",
                "        const commentItem = document.createElement('li');",
                "        commentItem.classList.add('bg-gray-800', 'p-4', 'rounded-md', 'mt-4', 'comment-item', 'flex', 'flex-col', 'space-y-2');",
                "        if (level > 0) {",
                "            commentItem.classList.add('ml-12', 'border-l-2', 'border-gray-700', 'pl-4');",
                "        }",
                "",
                "        const avatar = generateAvatar(comment.name);",
                "        const commentHeader = document.createElement('div');",
                "        commentHeader.classList.add('flex', 'items-start', 'space-x-4');",
                "",
                "        const avatarWrapper = document.createElement('div');",
                "        avatarWrapper.innerHTML = avatar;",
                "        commentHeader.appendChild(avatarWrapper);",
                "",
                "        const commentContent = document.createElement('div');",
                "        commentContent.classList.add('flex', 'flex-col', 'space-y-1', 'flex-grow');",
                "",
                "        const commentAuthor = document.createElement('div');",
                "        commentAuthor.classList.add('flex', 'items-center', 'justify-between', 'mt-1');",
                "",
                "        const authorNameDate = document.createElement('div');",
                "        authorNameDate.classList.add('flex', 'flex-col');",
                "",
                "        const authorName = document.createElement('p');",
                "        authorName.classList.add('flex', 'text-lg', 'font-semibold');",
                "        authorName.textContent = comment.name;",
                "",
                "        const commentDate = document.createElement('p');",
                "        commentDate.classList.add('text-sm', 'text-gray-400');",
                "        commentDate.textContent = new Date(comment.created_at).toLocaleString(); // Format the timestamp to local time",
                "",
                "        authorNameDate.appendChild(authorName);",
                "        authorNameDate.appendChild(commentDate);",
                "",
                "        commentAuthor.appendChild(authorNameDate);",
                "",
                "        const commentText = document.createElement('p');",
                "        commentText.classList.add('flex', 'text-lg', 'font-medium');",
                "        commentText.textContent = comment.content;",
                "",
                "        commentContent.appendChild(commentAuthor);",
                "        commentContent.appendChild(commentText);",
                "",
                "        commentHeader.appendChild(commentContent);",
                "        commentItem.appendChild(commentHeader);",
                "",
                "        const replyButton = document.createElement('button');",
                "        replyButton.classList.add('reply-button', 'mt-2', 'text-blue-400', 'hover:text-blue-300', 'transition', 'duration-200', 'self-start');",
                "        replyButton.setAttribute('data-comment-id', comment.id);",
                "        replyButton.textContent = 'Reply';",
                "",
                "        const replyForm = createReplyForm(comment.id);",
                "",
                "        commentItem.appendChild(replyButton);",
                "        commentItem.appendChild(replyForm);",
                "",
                "        return commentItem;",
                "    }",
                "",
                "    // Function to create a reply form for a comment",
                "    function createReplyForm(commentId) {",
                "        const replyForm = document.createElement('form');",
                "        replyForm.classList.add('reply-form', 'hidden', 'mt-2', 'flex', 'flex-col', 'space-y-2');",
                "        replyForm.setAttribute('data-comment-id', commentId);",
                "",
                "        const replyName = document.createElement('input');",
                "        replyName.classList.add('reply-name', 'w-full', 'p-2', 'rounded-md', 'bg-gray-900');",
                "        replyName.setAttribute('type', 'text');",
                "        replyName.setAttribute('name', 'name');",
                "        replyName.setAttribute('placeholder', 'Your Name');",
                "",
                "        const replyContent = document.createElement('textarea');",
                "        replyContent.classList.add('reply-content', 'w-full', 'p-2', 'rounded-md', 'bg-gray-900');",
                "        replyContent.setAttribute('name', 'content');",
                "        replyContent.setAttribute('placeholder', 'Your Reply');",
                "",
                "        const parentId = document.createElement('input');",
                "        parentId.setAttribute('type', 'hidden');",
                "        parentId.setAttribute('name', 'parent_id');",
                "        parentId.setAttribute('value', commentId);",
                "",
                "        const wordId = document.createElement('input');",
                "        wordId.setAttribute('type', 'hidden');",
                "        wordId.setAttribute('name', 'word_id');",
                "        wordId.setAttribute('value', word);",
                "",
                "        const submitButton = document.createElement('button');",
                "        submitButton.classList.add('reply-submit', 'bg-blue-500', 'hover:bg-blue-400', 'text-white', 'p-2', 'rounded-md', 'transition', 'duration-200');",
                "        submitButton.setAttribute('type', 'submit');",
                "        submitButton.textContent = 'Submit Reply';",
                "",
                "        replyForm.appendChild(replyName);",
                "        replyForm.appendChild(replyContent);",
                "        replyForm.appendChild(parentId);",
                "        replyForm.appendChild(wordId);",
                "        replyForm.appendChild(submitButton);",
                "",
                "        return replyForm;",
                "    }",
                "",
                "    // Function to handle comment submission",
                "    function handleCommentSubmit(event) {",
                "        event.preventDefault();",
                "        const form = event.target;",
                "        const formData = new FormData(form);",
                "        submitCommentForm(formData);",
                "    }",
                "",
                "    // Function to handle reply button click",
                "    function handleReplyButtonClick(event) {",
                "        if (event.target.classList.contains('reply-button')) {",
                "            const replyForm = event.target.nextElementSibling;",
                "            replyForm.classList.toggle('hidden');",
                "        }",
                "    }",
                "",
                "    // Function to handle reply form submission",
                "    function handleReplyFormSubmit(event) {",
                "        if (event.target.classList.contains('reply-form')) {",
                "            event.preventDefault();",
                "            const form = event.target;",
                "            const formData = new FormData(form);",
                "            submitCommentForm(formData);",
                "            form.classList.add('hidden');",
                "        }",
                "    }",
                "",
                "    // Function to submit a comment form",
                "    function submitCommentForm(formData) {",
                "        fetch('/api/comments', {",
                "            method: 'POST',",
                "            body: formData",
                "        })",
                "            .then(response => response.json())",
                "            .then(comment => {",
                "                const parentCommentId = formData.get('parent_id');",
                "                if (parentCommentId) {",
                "                    const parentComment = commentsContainer.querySelector(`li[data-comment-id='${parentCommentId}']`);",
                "                    const replyList = parentComment.querySelector('ul') || document.createElement('ul');",
                "                    if (!parentComment.contains(replyList)) parentComment.appendChild(replyList);",
                "                    const commentItem = createCommentItem(comment, replyList.dataset.level || 1);",
                "                    replyList.appendChild(commentItem);",
                "                } else {",
                "                    const commentItem = createCommentItem(comment, 0);",
                "                    commentsContainer.querySelector('ul').appendChild(commentItem);",
                "                }",
                "                applyTheme(); // Apply theme to newly added elements",
                "            })",
                "            .catch(error => {",
                "                console.error('Error submitting comment:', error);",
                "            });",
                "    }",
                "",
                "    // Function to generate an avatar based on the name",
                "    function generateAvatar(name) {",
                "        const initials = name.split(' ').map(word => word[0].toUpperCase()).join('');",
                "        const avatarColors = [",
                "            '#E57373', '#F06292', '#BA68C8', '#9575CD',",
                "            '#7986CB', '#64B5F6', '#4FC3F7', '#4DB6AC',",
                "            '#81C784', '#AED581', '#DCE775', '#FFD54F',",
                "            '#FFB74D', '#FF8A65', '#A1887F', '#90A4AE'",
                "        ];",
                "        const color = avatarColors[Math.floor(Math.random() * avatarColors.length)];",
                "        return `",
                "            <div class=\"flex items-center justify-center w-12 h-12 rounded-full\" style=\"background-color: ${color};\">",
                "                <span class=\"text-white text-lg font-medium\">${initials}</span>",
                "            </div>",
                "        `;",
                "    }",
                "",
                "    function applyTheme() {",
                "        const isDarkMode = document.body.classList.contains('dark-mode');",
                "        document.querySelectorAll('.comment-item').forEach(commentItem => {",
                "            commentItem.style.backgroundColor = isDarkMode ? '#2d3748' : '#ffffff';",
                "            commentItem.style.color = isDarkMode ? '#f9f9f9' : '#1a202c';",
                "        });",
                "    }",
                "",
                "});"
            ],
            "notes": [
                "Includes functions to fetch word details, display them, and handle comments."
            ]
        }
    },
    {
        "id": "15",
        "name": "wordOfTheDay.js",
        "path": "client/js/wordOfTheDay.js",
        "description": "JavaScript file for displaying the word of the day.",
        "details": {
            "purpose": "Fetches and displays the word of the day from the API.",
            "content": [
                "document.addEventListener('DOMContentLoaded', function() {",
                "    const wordOfTheDayContainer = document.getElementById('word-of-the-day-container');",
                "    const preloader = document.getElementById('preloader');",
                "",
                "    // Fetch the word of the day from the API",
                "    fetch('/api/word-of-the-day')",
                "        .then(response => response.json())",
                "        .then(data => {",
                "            displayWordOfTheDay(data);",
                "            preloader.style.display = 'none'; // Hide the preloader after loading the word of the day",
                "        })",
                "        .catch(error => {",
                "            console.error('Error fetching word of the day:', error);",
                "            preloader.style.display = 'none';",
                "            wordOfTheDayContainer.innerHTML = '<p class=\"text-red-500 text-center\">Error loading word of the day. Please try again later.</p>';",
                "        });",
                "",
                "    // Display the word of the day in the HTML",
                "    function displayWordOfTheDay(word) {",
                "        const wordHTML = `",
                "            <div class=\"word-item rounded-md\">",
                "                <h2 class=\"text-3xl font-bold mb-6 text-center\">${word.word}</h2>",
                "                <div class=\"mb-6\">",
                "                    <strong class=\"block text-xl mb-3\">Part of Speech:</strong>",
                "                    <span class=\"block text-lg\">${word.type}</span>",
                "                </div>",
                "                <div class=\"mb-6\">",
                "                    <strong class=\"block text-xl mb-3\">English Definitions:</strong>",
                "                    <ul class=\"list-disc list-inside text-lg\">",
                "                        ${word.definitions.map(def => `<li>${def}</li>`).join('')}",
                "                    </ul>",
                "                </div>",
                "                <div class=\"mb-6\">",
                "                    <strong class=\"block text-xl mb-3\">Translations:</strong>",
                "                    <ul class=\"text-lg\">",
                "                        ${word.translations.map(trans => `<li>${trans}</li>`).join('')}",
                "                    </ul>",
                "                </div>",
                "            </div>",
                "        `;",
                "        wordOfTheDayContainer.innerHTML = wordHTML;",
                "        applyTheme(); // Apply theme to newly added elements",
                "    }",
                "",
                "    // Theme Toggle",
                "    const themeToggle = document.getElementById('theme-toggle');",
                "    themeToggle.addEventListener('click', () => {",
                "        document.body.classList.toggle('dark-mode');",
                "        document.body.classList.toggle('light-mode');",
                "        applyTheme();",
                "    });",
                "",
                "    function applyTheme() {",
                "        const isDarkMode = document.body.classList.contains('dark-mode');",
                "        document.querySelectorAll('.word-item').forEach(item => {",
                "            item.style.backgroundColor = isDarkMode ? '#2d3748' : '#ffffff';",
                "            item.style.color = isDarkMode ? '#f9f9f9' : '#1a202c';",
                "        });",
                "    }",
                "",
                "    applyTheme(); // Apply the initial theme",
                "});"
            ],
            "notes": [
                "Includes functions to fetch and display the word of the day."
            ]
        }
    },
    {
        "id": "16",
        "name": "theme-toggle.js",
        "path": "client/js/utils/theme-toggle.js",
        "description": "JavaScript file for toggling the theme.",
        "details": {
            "purpose": "Handles theme switching between light and dark modes.",
            "content": [
                "document.addEventListener('DOMContentLoaded', function() {",
                "    const themeToggle = document.getElementById('theme-toggle');",
                "    const body = document.body;",
                "    const navbar = document.getElementById('navbar');",
                "    const instructionsIconLight = document.getElementById('instructionsIconLight');",
                "    const instructionsIconDark = document.getElementById('instructionsIconDark');",
                "    const githubIcon = document.querySelector('.icon[alt=\"GitHub\"]');",
                "    const instructionsModal = document.getElementById('instructionsModal');",
                "    const closeButton = document.querySelector('.modal-close-button');",
                "",
                "    // Load the saved theme from localStorage, default to dark-mode if not set",
                "    const savedTheme = localStorage.getItem('theme') || 'dark-mode';",
                "    body.classList.remove('light-mode', 'dark-mode');",
                "    body.classList.add(savedTheme);",
                "    navbar.classList.remove('light-mode', 'dark-mode');",
                "    navbar.classList.add(savedTheme);",
                "",
                "    // Set the initial icon based on the theme",
                "    themeToggle.src = savedTheme === 'dark-mode' ? 'https://img.icons8.com/ios-glyphs/30/ffffff/moon-symbol.png' : 'https://img.icons8.com/ios-glyphs/30/000000/sun.png';",
                "    instructionsIconLight.classList.toggle('hidden', savedTheme === 'dark-mode');",
                "    instructionsIconDark.classList.toggle('hidden', savedTheme === 'light-mode');",
                "    githubIcon.src = savedTheme === 'dark-mode' ? 'https://img.icons8.com/material-outlined/24/ffffff/github.png' : 'https://img.icons8.com/material-outlined/24/000000/github.png';",
                "",
                "    // Toggle the theme on button click",
                "    themeToggle.addEventListener('click', () => {",
                "        if (body.classList.contains('light-mode')) {",
                "            body.classList.remove('light-mode');",
                "            body.classList.add('dark-mode');",
                "            navbar.classList.remove('light-mode');",
                "            navbar.classList.add('dark-mode');",
                "            themeToggle.src = 'https://img.icons8.com/ios-glyphs/30/ffffff/moon-symbol.png';",
                "            instructionsIconLight.classList.add('hidden');",
                "            instructionsIconDark.classList.remove('hidden');",
                "            githubIcon.src = 'https://img.icons8.com/material-outlined/24/ffffff/github.png';",
                "            localStorage.setItem('theme', 'dark-mode');",
                "        } else {",
                "            body.classList.remove('dark-mode');",
                "            body.classList.add('light-mode');",
                "            navbar.classList.remove('dark-mode');",
                "            navbar.classList.add('light-mode');",
                "            themeToggle.src = 'https://img.icons8.com/ios-glyphs/30/000000/sun.png';",
                "            instructionsIconLight.classList.remove('hidden');",
                "            instructionsIconDark.classList.add('hidden');",
                "            githubIcon.src = 'https://img.icons8.com/material-outlined/24/000000/github.png';",
                "            localStorage.setItem('theme', 'light-mode');",
                "        }",
                "    });",
                "",
                "    // Toggle instructions modal",
                "    window.toggleInstructionsModal = function(show) {  // <-- Expose the function globally",
                "        if (show) {",
                "            instructionsModal.classList.add('active');",
                "            document.body.style.overflow = 'hidden'; // Prevent background scrolling",
                "        } else {",
                "            instructionsModal.classList.remove('active');",
                "            document.body.style.overflow = 'auto'; // Re-enable background scrolling",
                "        }",
                "    }",
                "",
                "    // Add event listeners for the instruction icons and close button",
                "    instructionsIconLight.addEventListener('click', () => toggleInstructionsModal(true));",
                "    instructionsIconDark.addEventListener('click', () => toggleInstructionsModal(true));",
                "    closeButton.addEventListener('click', () => toggleInstructionsModal(false));",
                "",
                "    // Close modal when clicking outside of it",
                "    window.addEventListener('click', (event) => {",
                "        if (event.target === instructionsModal) {",
                "            toggleInstructionsModal(false);",
                "        }",
                "    });",
                "});"
            ],
            "notes": [
                "Includes functions to toggle between light and dark themes and apply the selected theme."
            ]
        }
    },
    {
        "id": "17",
        "name": "flashcard.js",
        "path": "client/js/games/flashcard.js",
        "description": "JavaScript file for the flashcard game functionality.",
        "details": {
            "purpose": "Implements the logic for a flashcard game, including card flipping and game logic.",
            "content": [
                "document.addEventListener('DOMContentLoaded', function() {",
                "    const memoryGame = document.getElementById('memory-game');",
                "    let hasFlippedCard = false;",
                "    let lockBoard = false;",
                "    let firstCard, secondCard;",
                "    let matchedPairs = 0;",
                "",
                "    // Function to fetch game data from the server",
                "    async function fetchGameData() {",
                "        try {",
                "            const response = await fetch('/api/games/flashcard');",
                "            if (!response.ok) {",
                "                throw new Error('Network response was not ok');",
                "            }",
                "            const data = await response.json();",
                "            return data;",
                "        } catch (error) {",
                "            console.error('Error fetching game data:', error);",
                "            return null;",
                "        }",
                "    }",
                "",
                "    // Function to create memory cards",
                "    function createMemoryCards(words) {",
                "        memoryGame.innerHTML = ''; // Clear existing cards",
                "        matchedPairs = 0; // Reset matched pairs count",
                "        words.forEach(wordObj => {",
                "            const card = document.createElement('div');",
                "            card.classList.add('memory-card');",
                "            card.dataset.framework = wordObj.word;",
                "",
                "            const frontFace = document.createElement('div');",
                "            frontFace.classList.add('front-face');",
                "            frontFace.innerHTML = `<div class=\"word\">${wordObj.word}</div><div class=\"definition\">${wordObj.definition}</div>`;",
                "",
                "            const backFace = document.createElement('div');",
                "            backFace.classList.add('back-face');",
                "            backFace.textContent = '?'; // Placeholder symbol",
                "",
                "            card.appendChild(frontFace);",
                "            card.appendChild(backFace);",
                "",
                "            card.addEventListener('click', flipCard);",
                "            memoryGame.appendChild(card);",
                "        });",
                "",
                "        // Shuffle the cards",
                "        (function shuffle() {",
                "            const cards = document.querySelectorAll('.memory-card');",
                "            cards.forEach(card => {",
                "                let randomPos = Math.floor(Math.random() * 12);",
                "                card.style.order = randomPos;",
                "            });",
                "        })();",
                "    }",
                "",
                "    // Function to flip a card",
                "    function flipCard() {",
                "        if (lockBoard) return;",
                "        if (this === firstCard) return;",
                "",
                "        this.classList.add('flip');",
                "",
                "        if (!hasFlippedCard) {",
                "            hasFlippedCard = true;",
                "            firstCard = this;",
                "            return;",
                "        }",
                "",
                "        secondCard = this;",
                "        checkForMatch();",
                "    }",
                "",
                "    // Function to check if two cards match",
                "    function checkForMatch() {",
                "        let isMatch = firstCard.dataset.framework === secondCard.dataset.framework;",
                "        isMatch ? disableCards() : unflipCards();",
                "    }",
                "",
                "    // Function to disable matched cards",
                "    function disableCards() {",
                "        firstCard.removeEventListener('click', flipCard);",
                "        secondCard.removeEventListener('click', flipCard);",
                "        firstCard.classList.add('glow');",
                "        secondCard.classList.add('glow');",
                "        matchedPairs += 1; // Increment matched pairs count",
                "        if (matchedPairs === 6) { // All pairs matched",
                "            setTimeout(restartGame, 1500); // Restart game after a short delay",
                "        }",
                "        resetBoard();",
                "    }",
                "",
                "    // Function to unflip unmatched cards",
                "    function unflipCards() {",
                "        lockBoard = true;",
                "        setTimeout(() => {",
                "            firstCard.classList.remove('flip');",
                "            secondCard.classList.remove('flip');",
                "            resetBoard();",
                "        }, 1500);",
                "    }",
                "",
                "    // Function to reset the board",
                "    function resetBoard() {",
                "        [hasFlippedCard, lockBoard] = [false, false];",
                "        [firstCard, secondCard] = [null, null];",
                "    }",
                "",
                "    // Function to restart the game",
                "    async function restartGame() {",
                "        const gameData = await fetchGameData();",
                "        if (gameData) {",
                "            createMemoryCards(gameData);",
                "        } else {",
                "            memoryGame.innerHTML = '<p class=\"text-red-500\">Failed to load game data. Please try again later.</p>';",
                "        }",
                "    }",
                "",
                "    // Initialize the game",
                "    async function init() {",
                "        await restartGame();",
                "        applyTheme(); // Apply the current theme initially",
                "    }",
                "",
                "    // Theme Toggle",
                "    const themeToggle = document.getElementById('theme-toggle');",
                "    themeToggle.addEventListener('click', () => {",
                "        document.body.classList.toggle('dark-mode');",
                "        applyTheme();",
                "    });",
                "",
                "    function applyTheme() {",
                "        const isDarkMode = document.body.classList.contains('dark-mode');",
                "        document.querySelectorAll('.memory-card').forEach(card => {",
                "            card.style.backgroundColor = isDarkMode ? '#2d3748' : '#f7fafc';",
                "            card.style.color = isDarkMode ? '#f9f9f9' : '#1a202c';",
                "        });",
                "    }",
                "",
                "    init();",
                "});"
            ],
            "notes": [
                "Includes functions to manage the flashcard game state, card flipping animations, and scoring."
            ]
        }
    },
    {
        "id": "18",
        "name": "resourcesService.js",
        "path": "server/services/resources/resourcesService.js",
        "description": "JavaScript file for resource services.",
        "details": {
            "purpose": "Service layer for handling resource-related operations.",
            "content": [
                "// resourcesService.js content goes here."
            ],
            "notes": [
                "Currently empty. To be implemented."
            ]
        }
    },
    {
        "id": "19",
        "name": "lessonsService.js",
        "path": "server/services/lessons/lessonsService.js",
        "description": "JavaScript file for lesson services.",
        "details": {
            "purpose": "Service layer for handling lesson-related operations.",
            "content": [
                "// lessonsService.js content goes here."
            ],
            "notes": [
                "Currently empty. To be implemented."
            ]
        }
    },
    {
        "id": "20",
        "name": "app.js",
        "path": "server/app.js",
        "description": "Main application file for the server.",
        "details": {
            "purpose": "Sets up the server with routes and middleware.",
            "content": [
                "const express = require('express');",
                "const cors = require('cors');",
                "const path = require('path');",
                "const dictionaryRoutes = require('./routes/dictionaryRoutes');",
                "const wordOfTheDayRoutes = require('./routes/wordOfTheDayRoutes');",
                "const aiRoutes = require('./routes/aiRoutes');",
                "const commentsRoutes = require('./routes/commentsRoutes');",
                "const gamesRoutes = require('./routes/games/gamesRoutes');",
                "",
                "const app = express();",
                "",
                "// Middleware setup",
                "app.use(cors());",
                "app.use(express.json());",
                "app.use(express.static(path.join(__dirname, '..', 'client')));",
                "",
                "// Route setup",
                "app.use('/api', dictionaryRoutes);",
                "app.use('/api', wordOfTheDayRoutes);",
                "app.use('/api', aiRoutes);",
                "app.use('/api', commentsRoutes);",
                "app.use('/api/games', gamesRoutes);",
                "",
                "// Serve HTML files for different routes",
                "app.get('/', (req, res) => {",
                "    res.sendFile(path.join(__dirname, '..', 'client', 'pages', 'index.html'));",
                "});",
                "",
                "app.get('/education', (req, res) => {",
                "    res.sendFile(path.join(__dirname, '..', 'client', 'pages', 'education.html'));",
                "});",
                "",
                "app.get('/dictionary', (req, res) => {",
                "    res.sendFile(path.join(__dirname, '..', 'client', 'pages', 'dictionary.html'));",
                "});",
                "",
                "app.get('/word-details', (req, res) => {",
                "    res.sendFile(path.join(__dirname, '..', 'client', 'pages', 'word-details.html'));",
                "});",
                "",
                "app.get('/games/flashcard', (req, res) => {",
                "    res.sendFile(path.join(__dirname, '..', 'client', 'games', 'flashcard.html'));",
                "});",
                "",
                "// Catch-all to serve HTML files correctly from any nested route",
                "app.get('/*', (req, res) => {",
                "    const filePath = path.join(__dirname, '..', 'client', 'pages', req.params[0]);",
                "    res.sendFile(filePath, (err) => {",
                "        if (err) {",
                "            res.status(404).send('Not Found');",
                "        }",
                "    });",
                "});",
                "",
                "module.exports = app;"
            ],
            "notes": [
                "Sets up the Express application with routes and middleware."
            ]
        }
    },
    {
        "id": "21",
        "name": "server.js",
        "path": "server/server.js",
        "description": "Server entry point.",
        "details": {
            "purpose": "Starts the server and sets up the cron job for updating the word of the day.",
            "content": [
                "require('dotenv').config();",
                "const app = require('./app');",
                "const cron = require('node-cron');",
                "const axios = require('axios');",
                "",
                "const port = process.env.PORT || 3001;",
                "",
                "app.listen(port, () => {",
                "    console.log(`Server is running on http://localhost:${port}`);",
                "});",
                "",
                "// Schedule the cron job to run daily at midnight",
                "cron.schedule('0 0 * * *', async () => {",
                "    try {",
                "        await axios.put(`http://localhost:${port}/api/word-of-the-day/update`);",
                "        console.log('Word of the Day updated successfully');",
                "    } catch (error) {",
                "        console.error('Error updating Word of the Day:', error);",
                "    }",
                "});"
            ],
            "notes": [
                "Includes server setup and cron job scheduling for daily updates."
            ]
        }
    },
    {
        "id": "22",
        "name": "aiService.js",
        "path": "server/services/aiService.js",
        "description": "Service for interacting with the OpenAI API.",
        "details": {
            "purpose": "Generates facts using the OpenAI API.",
            "content": [
                "const openai = require('../config/openai');",
                "",
                "// Service method to generate a fact using OpenAI Chat API",
                "exports.generateFact = async ({ word, type, translations, definitions }) => {",
                "    try {",
                "        // Send a request to the OpenAI API with the specified prompt and parameters",
                "        const response = await openai.chat.completions.create({",
                "            model: 'gpt-4',",
                "            messages: [",
                "                {",
                "                    role: 'system',",
                "                    content: `You are a knowledgeable Mi'gmaq linguist. Share an insightful fact or story about the word \"${word}\", its origins, and its cultural significance. Keep it short between 1-2 sentences.`,",
                "                },",
                "                {",
                "                    role: 'user',",
                "                    content: `Word: ${word}\\nType: ${type}\\nTranslations: ${translations}\\nDefinitions: ${definitions}`,",
                "                },",
                "            ],",
                "            temperature: 1,",
                "            max_tokens: 100,",
                "            top_p: 1,",
                "            frequency_penalty: 0,",
                "            presence_penalty: 0,",
                "        });",
                "",
                "        // Extract and return the generated fact from the API response",
                "        return response.choices[0].message.content;",
                "    } catch (error) {",
                "        console.error('Error generating fact with OpenAI:', error.response ? error.response.data : error.message);",
                "        throw error;",
                "    }",
                "};"
            ],
            "notes": [
                "Handles fact generation using the OpenAI Chat API."
            ]
        }
    },
    {
        "id": "23",
        "name": "commentsService.js",
        "path": "server/services/commentsService.js",
        "description": "Service for managing comments.",
        "details": {
            "purpose": "Fetches and adds comments from/to the database.",
            "content": [
                "const supabase = require('../config/database');",
                "",
                "// Function to fetch comments for a given wordId",
                "exports.getComments = async (wordId) => {",
                "    try {",
                "        const { data, error } = await supabase",
                "            .from('comments')",
                "            .select('*')",
                "            .eq('word_id', wordId) // Filter comments by wordId",
                "            .order('created_at', { ascending: true }); // Order comments by creation time",
                "",
                "        if (error) throw error;",
                "        return data; // Return the fetched comments",
                "    } catch (error) {",
                "        console.error('Error fetching comments:', error);",
                "        throw error;",
                "    }",
                "};",
                "",
                "// Function to add a new comment",
                "exports.addComment = async (comment) => {",
                "    try {",
                "        // Set the created_at field to the current UTC time",
                "        comment.created_at = new Date().toISOString();",
                "",
                "        const { data, error } = await supabase",
                "            .from('comments')",
                "            .insert([comment]) // Insert the new comment into the database",
                "            .select(); // Select the inserted comment",
                "",
                "        if (error) throw error;",
                "        return data[0]; // Return the inserted comment",
                "    } catch (error) {",
                "        console.error('Error adding comment:', error);",
                "        throw error;",
                "    }",
                "};"
            ],
            "notes": [
                "Handles fetching and adding comments to the database."
            ]
        }
    },
    {
        "id": "24",
        "name": "dictionaryService.js",
        "path": "server/services/dictionaryService.js",
        "description": "Service for managing dictionary data.",
        "details": {
            "purpose": "Fetches dictionary data from a JSON file.",
            "content": [
                "const fs = require('fs').promises;",
                "const path = require('path');",
                "",
                "const dictionaryFilePath = path.join(__dirname, '..', '..', 'client', 'assets', 'dictionary.json');",
                "",
                "// Function to get the full dictionary",
                "exports.getDictionary = async () => {",
                "    try {",
                "        const data = await fs.readFile(dictionaryFilePath, 'utf8'); // Read the dictionary file",
                "        const parsedData = JSON.parse(data); // Parse the JSON data",
                "        return parsedData.message.words; // Return the words from the parsed data",
                "    } catch (error) {",
                "        console.error('Error reading dictionary file:', error);",
                "        throw new Error('Error reading dictionary file'); // Throw an error if reading fails",
                "    }",
                "};",
                "",
                "// Function to get details of a specific word",
                "exports.getWordDetails = async (word) => {",
                "    try {",
                "        const data = await fs.readFile(dictionaryFilePath, 'utf8'); // Read the dictionary file",
                "        const dictionary = JSON.parse(data).message.words; // Parse the JSON data",
                "        const wordDetails = dictionary.find(item => item.word === word); // Find the word details",
                "        if (!wordDetails) throw new Error('Word not found');",
                "        return wordDetails; // Return the word details",
                "    } catch (error) {",
                "        console.error('Error reading dictionary file:', error);",
                "        throw new Error('Error reading dictionary file'); // Throw an error if reading fails",
                "    }",
                "};"
            ],
            "notes": [
                "Handles fetching and parsing dictionary data from a JSON file."
            ]
        }
    },
    {
        "id": "25",
        "name": "wordOfTheDayService.js",
        "path": "server/services/wordOfTheDayService.js",
        "description": "Service for managing the word of the day.",
        "details": {
            "purpose": "Fetches, updates, and manages the word of the day in Supabase.",
            "content": [
                "const supabase = require('../config/database');",
                "const fs = require('fs').promises;",
                "const path = require('path');",
                "",
                "// Path to the dictionary file",
                "const dictionaryFilePath = path.join(__dirname, '..', '..', 'client', 'assets', 'dictionary.json');",
                "",
                "// Function to get the current word of the day from Supabase",
                "exports.getWordOfTheDay = async () => {",
                "    try {",
                "        const { data, error } = await supabase",
                "            .from('word_of_the_day')",
                "            .select('*')",
                "            .order('created_at', { ascending: false })",
                "            .limit(1)",
                "            .single();",
                "",
                "        // If no word of the day is found, select a random word from the dictionary",
                "        if (error && error.code === 'PGRST116') {",
                "            const randomWord = await exports.selectRandomWord();",
                "            await exports.addWordOfTheDay(randomWord);",
                "            return randomWord;",
                "        } else if (error) {",
                "            throw new Error('Failed to fetch word of the day');",
                "        }",
                "",
                "        return data;",
                "    } catch (err) {",
                "        throw err;",
                "    }",
                "};",
                "",
                "// Function to add a new word of the day to Supabase",
                "exports.addWordOfTheDay = async (wordData) => {",
                "    if (!wordData || typeof wordData !== 'object') {",
                "        throw new Error('Invalid word data');",
                "    }",
                "",
                "    try {",
                "        const { data, error } = await supabase",
                "            .from('word_of_the_day')",
                "            .insert([wordData]);",
                "",
                "        if (error) {",
                "            throw new Error('Failed to add word of the day');",
                "        }",
                "",
                "        return data;",
                "    } catch (err) {",
                "        throw err;",
                "    }",
                "};",
                "",
                "// Function to select a random word from the dictionary file",
                "exports.selectRandomWord = async () => {",
                "    try {",
                "        const data = await fs.readFile(dictionaryFilePath, 'utf8');",
                "        const dictionary = JSON.parse(data);",
                "",
                "        if (!Array.isArray(dictionary.message.words) || dictionary.message.words.length === 0) {",
                "            throw new Error('Dictionary is empty or not an array');",
                "        }",
                "",
                "        const randomIndex = Math.floor(Math.random() * dictionary.message.words.length);",
                "        const randomWord = dictionary.message.words[randomIndex];",
                "        return randomWord;",
                "    } catch (err) {",
                "        throw err;",
                "    }",
                "};",
                "",
                "// Function to update the word of the day in Supabase",
                "exports.updateWordOfTheDay = async () => {",
                "    try {",
                "        const randomWord = await exports.selectRandomWord();",
                "        await exports.deletePreviousWords();",
                "        await exports.addWordOfTheDay(randomWord);",
                "    } catch (err) {",
                "        throw err;",
                "    }",
                "};",
                "",
                "// Function to delete all previous words of the day from Supabase",
                "exports.deletePreviousWords = async () => {",
                "    try {",
                "        const { error } = await supabase",
                "            .from('word_of_the_day')",
                "            .delete()",
                "            .neq('id', -1); // Delete all rows",
                "",
                "        if (error) {",
                "            throw new Error('Failed to delete previous words');",
                "        }",
                "    } catch (err) {",
                "        throw err;",
                "    }",
                "};"
            ],
            "notes": [
                "Handles fetching, adding, and updating the word of the day."
            ]
        }
    },
    {
        "id": "26",
        "name": "gamesService.js",
        "path": "server/services/games/gamesService.js",
        "description": "Service for managing game data.",
        "details": {
            "purpose": "Fetches random words for the flashcard game.",
            "content": [
                "const fs = require('fs').promises;",
                "const path = require('path');",
                "",
                "// Path to the dictionary file",
                "const dictionaryFilePath = path.join(__dirname, '..', '..', '..', 'client', 'assets', 'dictionary.json');",
                "",
                "// Function to get random words from the dictionary",
                "async function getRandomWords(count = 6) {",
                "    try {",
                "        const data = await fs.readFile(dictionaryFilePath, 'utf8');",
                "        const dictionary = JSON.parse(data);",
                "",
                "        if (!Array.isArray(dictionary.message.words) || dictionary.message.words.length === 0) {",
                "            throw new Error('Dictionary is empty or not an array');",
                "        }",
                "",
                "        // Shuffle the words and select the first 'count' words",
                "        const shuffledWords = dictionary.message.words.sort(() => 0.5 - Math.random());",
                "        const selectedWords = shuffledWords.slice(0, count);",
                "",
                "        // Duplicate the words to create pairs and shuffle again",
                "        const wordPairs = [...selectedWords, ...selectedWords].sort(() => 0.5 - Math.random());",
                "",
                "        // Return words with definitions",
                "        return wordPairs.map(wordObj => ({",
                "            word: wordObj.word,",
                "            definition: wordObj.definitions ? wordObj.definitions[0] : 'No definition available' // Select the first definition",
                "        }));",
                "    } catch (error) {",
                "        throw new Error('Error reading dictionary file');",
                "    }",
                "}",
                "",
                "// Function to get game data based on the game type",
                "exports.getGameData = async (gameType) => {",
                "    switch (gameType) {",
                "        case 'flashcard':",
                "            return await getRandomWords();",
                "        // Add cases for other game types here",
                "        default:",
                "            throw new Error('Invalid game type');",
                "    }",
                "};"
            ],
            "notes": [
                "Handles fetching random words for the flashcard game."
            ]
        }
    },
    {
        "id": "27",
        "name": "lessonsRoutes.js",
        "path": "server/routes/lessons/lessonsRoutes.js",
        "description": "Express route for lesson-related operations.",
        "details": {
            "purpose": "Handles routing for lesson-related endpoints.",
            "content": [
                "// lessonsRoutes.js content goes here."
            ],
            "notes": [
                "Currently empty. To be implemented."
            ]
        }
    },
    {
        "id": "28",
        "name": "resourcesRoutes.js",
        "path": "server/routes/resources/resourcesRoutes.js",
        "description": "Express route for resource-related operations.",
        "details": {
            "purpose": "Handles routing for resource-related endpoints.",
            "content": [
                "// resourcesRoutes.js content goes here."
            ],
            "notes": [
                "Currently empty. To be implemented."
            ]
        }
    },
    {
        "id": "29",
        "name": "resourcesController.js",
        "path": "server/controllers/resources/resourcesController.js",
        "description": "Controller for handling resource-related requests.",
        "details": {
            "purpose": "Manages resource-related operations and business logic.",
            "content": [
                "// resourcesController.js content goes here."
            ],
            "notes": [
                "Currently empty. To be implemented."
            ]
        }
    },
    {
        "id": "30",
        "name": "lessonsController.js",
        "path": "server/controllers/lessons/lessonsController.js",
        "description": "Controller for handling lesson-related requests.",
        "details": {
            "purpose": "Manages lesson-related operations and business logic.",
            "content": [
                "// lessonsController.js content goes here."
            ],
            "notes": [
                "Currently empty. To be implemented."
            ]
        }
    },
    {
        "id": "31",
        "name": "aiRoutes.js",
        "path": "server/routes/aiRoutes.js",
        "description": "Express route for AI-related operations.",
        "details": {
            "purpose": "Handles routing for AI-related endpoints.",
            "content": [
                "const express = require('express');",
                "const router = express.Router();",
                "const aiController = require('../controllers/aiController');",
                "",
                "// Define the route to fetch interesting facts",
                "router.get('/fact', aiController.getFact);",
                "",
                "module.exports = router;"
            ],
            "notes": [
                "Includes routing for fetching AI-generated facts."
            ]
        }
    },
    {
        "id": "32",
        "name": "commentsRoutes.js",
        "path": "server/routes/commentsRoutes.js",
        "description": "Express route for comment-related operations.",
        "details": {
            "purpose": "Handles routing for comment-related endpoints.",
            "content": [
                "const express = require('express'); // Import the express module",
                "const router = express.Router(); // Create a new router object",
                "const commentsController = require('../controllers/commentsController'); // Import the comments controller",
                "",
                "// Define a route to get comments",
                "router.get('/comments', commentsController.getComments);",
                "",
                "// Define a route to add a new comment",
                "router.post('/comments', commentsController.addComment);",
                "",
                "module.exports = router; // Export the router"
            ],
            "notes": [
                "Includes routing for fetching and adding comments."
            ]
        }
    },
    {
        "id": "33",
        "name": "dictionaryRoutes.js",
        "path": "server/routes/dictionaryRoutes.js",
        "description": "Express route for dictionary-related operations.",
        "details": {
            "purpose": "Handles routing for dictionary-related endpoints.",
            "content": [
                "const express = require('express'); // Import the express module",
                "const router = express.Router(); // Create a new router object",
                "const dictionaryController = require('../controllers/dictionaryController'); // Import the dictionary controller",
                "",
                "// Define a route to get the dictionary",
                "router.get('/dictionary', dictionaryController.getDictionary);",
                "",
                "// Define a route to get details of a specific word",
                "router.get('/word-details', dictionaryController.getWordDetails);",
                "",
                "module.exports = router; // Export the router"
            ],
            "notes": [
                "Includes routing for fetching dictionary data and word details."
            ]
        }
    },
    {
        "id": "34",
        "name": "wordOfTheDayRoutes.js",
        "path": "server/routes/wordOfTheDayRoutes.js",
        "description": "Express route for word of the day operations.",
        "details": {
            "purpose": "Handles routing for word of the day endpoints.",
            "content": [
                "const express = require('express');",
                "const router = express.Router();",
                "const wordOfTheDayController = require('../controllers/wordOfTheDayController');",
                "",
                "// Route to get the current word of the day",
                "router.get('/word-of-the-day', wordOfTheDayController.getWordOfTheDay);",
                "",
                "// Route to add a new word of the day",
                "router.post('/word-of-the-day', wordOfTheDayController.addWordOfTheDay);",
                "",
                "// Route to update the word of the day",
                "router.put('/word-of-the-day/update', wordOfTheDayController.updateWordOfTheDay);",
                "",
                "module.exports = router;"
            ],
            "notes": [
                "Includes routing for fetching, adding, and updating the word of the day."
            ]
        }
    },
    {
        "id": "35",
        "name": "gamesRoutes.js",
        "path": "server/routes/games/gamesRoutes.js",
        "description": "Express route for game-related operations.",
        "details": {
            "purpose": "Handles routing for game-related endpoints.",
            "content": [
                "// server/routes/games/gamesRoutes.js",
                "const express = require('express');",
                "const router = express.Router();",
                "const gamesController = require('../../controllers/games/gamesController');",
                "",
                "// Route to get game data based on game type",
                "router.get('/:gameType', gamesController.getGameData);",
                "",
                "module.exports = router;"
            ],
            "notes": [
                "Includes routing for fetching game data."
            ]
        }
    },
    {
        "id": "36",
        "name": "aiController.js",
        "path": "server/controllers/aiController.js",
        "description": "Controller for handling AI-related requests.",
        "details": {
            "purpose": "Manages AI-related operations and business logic.",
            "content": [
                "const aiService = require('../services/aiService');",
                "",
                "// Controller method to handle the request for generating a fact",
                "exports.getFact = async (req, res) => {",
                "    try {",
                "        // Retrieve query parameters from the request",
                "        const { word, type, translations, definitions } = req.query;",
                "",
                "        // Call the service method to generate the fact",
                "        const fact = await aiService.generateFact({ word, type, translations, definitions });",
                "",
                "        // Send the generated fact in the response",
                "        res.json({ word, type, translations, definitions, fact });",
                "    } catch (error) {",
                "        console.error('Error generating fact:', error);",
                "        res.status(500).json({ error: 'Failed to generate fact' });",
                "    }",
                "};"
            ],
            "notes": [
                "Includes logic for handling requests to generate AI facts."
            ]
        }
    },
    {
        "id": "37",
        "name": "commentsController.js",
        "path": "server/controllers/commentsController.js",
        "description": "Controller for handling comment-related requests.",
        "details": {
            "purpose": "Manages comment-related operations and business logic.",
            "content": [
                "const commentsService = require('../services/commentsService'); // Import the comments service",
                "",
                "// Controller function to get comments",
                "exports.getComments = async (req, res) => {",
                "    const { word_id } = req.query; // Get the 'word_id' query parameter from the request",
                "    if (!word_id) {",
                "        return res.status(400).json({ error: 'word_id is required' }); // Respond with an error if 'word_id' is missing",
                "    }",
                "    try {",
                "        const comments = await commentsService.getComments(word_id); // Fetch comments from the service",
                "        res.json(comments); // Respond with the comments in JSON format",
                "    } catch (error) {",
                "        console.error('Error fetching comments:', error); // Log any errors",
                "        res.status(500).json({ error: 'Failed to fetch comments' }); // Respond with an error message",
                "    }",
                "};",
                "",
                "// Controller function to add a new comment",
                "exports.addComment = async (req, res) => {",
                "    const { word_id, parent_id, name, email, content } = req.body; // Get comment data from the request body",
                "    if (!word_id || !name || !email || !content) {",
                "        return res.status(400).json({ error: 'Missing required fields' }); // Respond with an error if any required fields are missing",
                "    }",
                "    try {",
                "        const newComment = await commentsService.addComment({ word_id, parent_id, name, email, content }); // Add the new comment using the service",
                "        res.json(newComment); // Respond with the new comment in JSON format",
                "    } catch (error) {",
                "        console.error('Error adding comment:', error); // Log any errors",
                "        res.status(500).json({ error: 'Failed to add comment' }); // Respond with an error message",
                "    }",
                "};"
            ],
            "notes": [
                "Includes logic for handling requests to fetch and add comments."
            ]
        }
    },
    {
        "id": "38",
        "name": "dictionaryController.js",
        "path": "server/controllers/dictionaryController.js",
        "description": "Controller for handling dictionary-related requests.",
        "details": {
            "purpose": "Manages dictionary-related operations and business logic.",
            "content": [
                "const dictionaryService = require('../services/dictionaryService'); // Import the dictionary service",
                "",
                "// Controller function to get the dictionary",
                "exports.getDictionary = async (req, res) => {",
                "    try {",
                "        const dictionary = await dictionaryService.getDictionary(); // Fetch the dictionary from the service",
                "        res.json(dictionary); // Respond with the dictionary in JSON format",
                "    } catch (error) {",
                "        console.error('Error fetching dictionary data:', error); // Log any errors",
                "        res.status(500).json({ error: 'Failed to fetch dictionary data' }); // Respond with an error message",
                "    }",
                "};",
                "",
                "// Controller function to get details of a specific word",
                "exports.getWordDetails = async (req, res) => {",
                "    const { word } = req.query; // Get the 'word' query parameter from the request",
                "    try {",
                "        const wordDetails = await dictionaryService.getWordDetails(word); // Fetch the word details from the service",
                "        res.json(wordDetails); // Respond with the word details in JSON format",
                "    } catch (error) {",
                "        console.error('Error fetching word details:', error); // Log any errors",
                "        res.status(500).json({ error: 'Failed to fetch word details' }); // Respond with an error message",
                "    }",
                "};"
            ],
            "notes": [
                "Includes logic for handling requests to fetch dictionary data and word details."
            ]
        }
    },
    {
        "id": "39",
        "name": "wordOfTheDayController.js",
        "path": "server/controllers/wordOfTheDayController.js",
        "description": "Controller for handling word of the day requests.",
        "details": {
            "purpose": "Manages word of the day operations and business logic.",
            "content": [
                "const wordOfTheDayService = require('../services/wordOfTheDayService');",
                "",
                "// Controller to get the current word of the day",
                "exports.getWordOfTheDay = async (req, res) => {",
                "    try {",
                "        const wordOfTheDay = await wordOfTheDayService.getWordOfTheDay();",
                "        res.json(wordOfTheDay);",
                "    } catch (error) {",
                "        res.status(500).json({ error: 'Failed to fetch word of the day' });",
                "    }",
                "};",
                "",
                "// Controller to add a new word of the day",
                "exports.addWordOfTheDay = async (req, res) => {",
                "    try {",
                "        const wordData = req.body;",
                "        const newWord = await wordOfTheDayService.addWordOfTheDay(wordData);",
                "        res.status(201).json(newWord);",
                "    } catch (error) {",
                "        res.status(500).json({ error: 'Failed to add word of the day' });",
                "    }",
                "};",
                "",
                "// Controller to update the word of the day",
                "exports.updateWordOfTheDay = async (req, res) => {",
                "    try {",
                "        await wordOfTheDayService.updateWordOfTheDay();",
                "        res.status(201).json({ message: 'Word of the Day updated successfully' });",
                "    } catch (error) {",
                "        res.status(500).json({ error: 'Failed to update word of the day' });",
                "    }",
                "};"
            ],
            "notes": [
                "Includes logic for handling requests to fetch, add, and update the word of the day."
            ]
        }
    }
]